<use-cases>

   <version>$Id: tmql-use-cases.xml,v 1.55 2007/01/08 05:36:06 rho Exp $</version>

   <database visible="no" title="TMQL Database">
     <description>TMQL Test database.</description>

     <data language="astma">
aaa
bn: AAA

bbb (ccc)
bn: BBB
bn@sss: BBBS
oc: http://something
oc (homepage): http://something2
oc: http://somethingelse
in@sss: something
in (comment): Bondpeoplearesoodumb

(special2)
r3 : p3
r4 : bbb

(special)
r1 : instance
r2 : something

(is-subclass-of)
subclass: bbb
superclass: sss

yyy (xxx)
bn: YYY

zzz (xxx)
bn: ZZZ

www (xxx)

#-- reification tests

(uuu) is-reified-by bbb
xxx : yyy
www : zzz

(uuu)
xxx : yyy
www : yyy

(uuu)
xxx : yyy
www : www

#-- prefix tests

rumsti = http://rumsti.org/ramsti
bn: Rumsti
sin: http://rumsti.org/remsti
sin: urn:x-whatever:remsti

rimsti ~ http://rumsti.org/rimsti
bn: Rimsti
     </data>

     <use-case qid="s000" title="null">
       <query title="null constant">
	 <interface>
	   <output type="list">
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( null )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
null
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s0001" title="literal string">
       <query title="single">
	 <interface>
	   <output type="list">
["rumsti"]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( "rumsti" )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
"rumsti"
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s0002" title="literal integer">
       <query title="integer constant">
	 <interface>
	   <output type="list">
[42]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( 42 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( "42"^^http://www.w3.org/2001/XMLSchema#integer )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
"42"^^http://www.w3.org/2001/XMLSchema#integer
]]></code>
	 </solution>
       </query>
       <query title="signed integer constant">
	 <interface>
	   <output type="list">
[-42]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( -42 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( "-42"^^http://www.w3.org/2001/XMLSchema#integer )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
"-42"^^http://www.w3.org/2001/XMLSchema#integer
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s0003" title="literal boolean">
       <query title="true">
	 <interface>
	   <output type="list">
[true]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( true )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
true
]]></code>
	 </solution>
       </query>
       <query title="true">
	 <interface>
	   <output type="list">
[false]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( false )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
false
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s0004" title="literal decimal">
       <query title="decimal constant">
	 <interface>
	   <output type="list">
[3.14]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( 3.14 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( "3.14"^^http://www.w3.org/2001/XMLSchema#decimal )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
"3.14"^^http://www.w3.org/2001/XMLSchema#decimal
]]></code>
	 </solution>
       </query>
       <query title="signed decimal constant">
	 <interface>
	   <output type="list">
[-3.14]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( -3.14 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( "-3.14"^^http://www.w3.org/2001/XMLSchema#decimal )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
"-3.14"^^http://www.w3.org/2001/XMLSchema#decimal
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s0021" title="tuple multivalue">
       <query title="multivalue">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
1,2,3
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( 1, 2, 3 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( 2, 1, 3 ) ( $1, $0, $2 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( (1), (1, 2) ( $1), 3 )
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s003" title="all">
       <query title="plain">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[...]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( %_ )
]]></code>
	 </solution>
       </query>
       <query title="all with @_">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[...]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( %_ ) ( @_ )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ ( @_ )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ ( . )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ ( @_ , @_ ) ($1)
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ [ 1 == 1 ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ [ . == . ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ [ $0 ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
(%_, %_) [ $0 == $1 ] ( $1 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
(%_, %_) [ $1 == $0 ] ( $0 )
]]></code>
	 </solution>
<!-- solution language="tmql" style="pe" operational="tyes">
 <code><![CDATA[
( %_ borken
]]></code>
</solution -->
       </query>

       <query title="all squared">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[......]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( %_, %_ )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( %_, %_ ) [  $# == $#  ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( %_, %_ ) ( @_ )
]]></code>
	 </solution>
       </query>

       <query title="nesting">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[...]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( %_ ) 
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( %_, %_ ) [ $0 == $1 ] ($0) 
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( %_, %_ ) [ ( $0 == $1 ) ] ($0) 
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( ( %_ ) ) 
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( ( ( %_ ) ) ) 
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s0031" title="all via projection">
       <query title="all with echo">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[...]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ ( @_ )
]]></code>
	 </solution>
       </query>
       <axiom language="tmql" operational="yes">
<code><![CDATA[
%_ ( $0 ) === %_
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
<code><![CDATA[
%_ ( $0, $0 ) ( $1 ) === %_
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
<code><![CDATA[
%_ ( $0, $0 ) ( $1, $0 ) ( $0 ) === %_
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
<code><![CDATA[
%_ ( $0, 1, $0 ) ( $2 ) === %_
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
<code><![CDATA[
%_ (.) === %_
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
<code><![CDATA[
%_ ( ., . ) (.) === %_
]]></code>
       </axiom>
     </use-case>

     <use-case qid="s0032" title="projection via identifier">
       <query title="tuple embedding">
	 <interface>
           <input>
             <param name="%_" type="map"    mutable="no"></param>
	   </input>
           <output type="list">
[bbb]
	   </output>
</interface>
         <solution language="tmql" style="pe" operational="yes">
           <code><![CDATA[
( bbb ) ( @_ )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb, ccc ) ( $1, $0 ) ( $1 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb, 2 ) ( $1, $0 ) ( $1 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( %_ // ccc, 2 ) ( $1, $0 ) ( $1 )
]]></code>
	 </solution>
       </query>
     </use-case>


     <use-case qid="s004" title="identifier">
       <query title="identifier">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( 1 ) ( bbb )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb ) ( aaa ) ( bbb )
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s005" title="predicates">
       <query title="constant vs constant">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb ) [ 1 == 1 ] 
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb ) [ $# == $# ] 
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb ) [ $# == 0 ] 
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb ) [ 0 ] 
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb  [ 0 ] 
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ [ . == bbb ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ [ bbb == . ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
(%_,%_) [ ( $0, bbb ) == ( bbb, $1 ) ] ( . )
]]></code>
	 </solution>
       </query>
       <axiom language="tmql" operational="yes">
	 <code><![CDATA[
%_ ( $# ) [ . == 2 ] === 2
]]></code>
       </axiom>
     </use-case>

     <use-case qid="s0051" title="filter one">
       <query title="filtering on #">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[body]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
%_ [ $# == 0 ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
%_ [ 0 ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
(%_,%_) [ @@@@@@@@@@@@@@@  $1 = bbb ] [ 0 ] ( $1 )
]]></code>
	 </solution>
       </query>
       <query title="bbb and then projection">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb],[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	 <code><![CDATA[
%_ [ $0 == bbb ] ( $0, $0 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	 <code><![CDATA[
%_ [ . / homepage ] ( . , . )
]]></code>
	 </solution>
       </query>
     </use-case>

<!-- navigation -->

     <use-case qid="s0061" title="epsilon navigation">
       <query title="epsilon navigation">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[...]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( %_ >> epsilon )
]]></code>
	 </solution>
       </query>
       <axiom language="tmql" operational="yes">
<code><![CDATA[
( %_ << epsilon ) === ( %_ >> epsilon )
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
<code><![CDATA[
( %_ << epsilon << epsilon ) === ( %_ )
]]></code>
       </axiom>
     </use-case>

     <use-case qid="s0062" title="class/instance navigation">
       <query title="type navigation">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[ccc]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb >> classes )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb ^ )
]]></code>
	 </solution>
       </query>

       <query title="instance navigation">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( ccc << classes)
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( ccc >> instances)
]]></code>
	 </solution>
       </query>

       <query title="predicated instance navigation">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ [ . >> classes == ccc ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ [ ^ ccc ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ // ccc
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
// ccc
]]></code>
	 </solution>
       </query>

       <axiom language="tmql" operational="yes">
<code><![CDATA[
( bbb >> classes << classes) === ( bbb )
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
	 <code><![CDATA[
( bbb >> classes >> instances) === ( bbb )
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
	 <code><![CDATA[
( ccc >> instances >> classes) === ( ccc )
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
	 <code><![CDATA[
( ccc >> instances >> classes ) === ( ccc )
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
	 <code><![CDATA[
( ccc <- class -> instance <- instance -> class ) === ( ccc )
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
	 <code><![CDATA[
( ccc >> instances >> classes ) === ( ccc )
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
	 <code><![CDATA[
%_ // xxx === %_ [ ^ xxx ]
]]></code>
       </axiom>
     </use-case>


     <use-case qid="s0063" title="classes navigation">
       <query title="classes navigation">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[bbb]
[sss]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> superclasses
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
sss  >> subclasses
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
sss << superclasses
]]></code>
	 </solution>
       </query>

       <query title="classes navigation (back/forth)">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[bbb]
[bbb]
[sss]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> superclasses >> subclasses
]]></code>
	 </solution>
       </query>

       <query title="superclasses navigation (back/forth)">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[bbb]
[sss]
[sss]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> superclasses >> superclasses
]]></code>
	 </solution>
       </query>
       <query title="superclasses navigation (back/forth)">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[bbb]
[bbb]
[sss]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
sss << superclasses << superclasses
]]></code>
	 </solution>
       </query>

<!-- TODO @@@ examples with more convoluted subclassing -->
     </use-case>

     <use-case qid="s0064" title="player navigation">
       <query title="player navigation">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[d2c44b6f1b8d2fae7a85855e29d359f0]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb << players r4 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( bbb <- r4 )
]]></code>
	 </solution>
       </query>

       <axiom language="tmql" operational="yes">
<code><![CDATA[
( bbb << players r4 >> players r4 ) === ( bbb )
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
<code><![CDATA[
( bbb << players r4 >> epsilon >> players r4 ) === ( bbb )
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
	 <code><![CDATA[
bbb <- r4 -> r4 === bbb
]]></code>
       </axiom>
       <query title="characteristics unatomified">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[4680378be83a353707df9b86e317b868]
[cae2cf3b2444b4066285832c284229f1]
[3cb5e893d6c7182c0e2cf43ec975fa8a]
[df94fa8c38a599e199b9525d8810f801]
[38c54f7568764f5f73b82aa9566b97fc]
[3e855fd3acec56043b9e98e613c7db40]
[109e8bdef3ec720de7c1e7ae316f7133]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics thing
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s010" title="atomification">
       <query title="all characteristics atomified">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"BBB"
"BBBS"
"something"
"http://something"
"http://something2"
"http://somethingelse"
"Bondpeoplearesoodumb"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics >> atomify
]]></code>
	 </solution>
       </query>
       <query title="homepage atomified">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"http://something2"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics homepage >> atomify
]]></code>
	 </solution>
       </query>
       <query title="homepage atomified/deatomified">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[3cb5e893d6c7182c0e2cf43ec975fa8a]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics homepage >> atomify << atomify
]]></code>
	 </solution>
       </query>
       <query title="deatomified">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[4680378be83a353707df9b86e317b868]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
"BBBS" << atomify
]]></code>
	 </solution>
       </query>
       <query title="deatomified/atomified">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"BBBS"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
"BBBS" << atomify >> atomify
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
"BBBS" << atomify [ @ sss ] ( . >> atomify )
]]></code>
	 </solution>
       </query>
       <query title="homepage deatomified char'ed">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="no">
	   <code><![CDATA[
<http://something2> << atomify << characteristics homepage
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="no">
	   <code><![CDATA[
<http://something2> \ homepage
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
"BBBS" << atomify << characteristics name
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
"BBBS" \ name
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s0066" title="indicator navigation">
       <query title="indicator navigation">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
"http://rumsti.org/remsti"
"urn:x-whatever:remsti"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( rumsti >> indicators )
]]></code>
	 </solution>
       </query>
       <query title="indicator navigation">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[rumsti]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="no">
	   <code><![CDATA[
( <http://rumsti.org/remsti> << indicators )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="no">
	   <code><![CDATA[
( <http://rumsti.org/remsti> ~ )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( http://rumsti.org/remsti )
]]></code>
	 </solution>
       </query>
       <query title="indicator navigation, noexistent">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="no">
	   <code><![CDATA[
( <http://does.not.exist/> << indicators )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="no">
	   <code><![CDATA[
( <http://does.not.exist/> ~ )
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s0067" title="locator navigation">
       <query title="forward">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
"http://rumsti.org/ramsti"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( rumsti >> locators )
]]></code>
	 </solution>
       </query>
       <query title="reverse">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[rumsti]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( "http://rumsti.org/ramsti" << locators )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( "http://rumsti.org/ramsti" = )
]]></code>
	 </solution>
       </query>
       <query title="locator navigation, noexistent">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( "http://does.not.exist/" << locators )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
( "http://does.not.exist/" = )
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s0081" title="scoping">
       <query title="scope retrieve">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[sss]
[us]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics name >> scope
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics name ( . >> scope )
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s012" title="reification">
       <query title="forward (topic to assoc)">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
zzz <- www << reifier
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> reifier << reifier
]]></code>
	 </solution>
       </query>
       <query title="backward (assoc to topic)">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[3cb9a89cb1f5580114d02497e5210ee5]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> reifier
]]></code>
	 </solution>
       </query>
       <axiom language="tmql" operational="yes">
	 <code><![CDATA[
zzz <- www << reifier >>  reifier  ===   zzz <- www
]]></code>
       </axiom>
       <axiom language="tmql" operational="yes">
	 <code><![CDATA[
bbb >> reifier << reifier         ===   bbb
]]></code>
       </axiom>
<!-- more tests for reifying characteristics -->
     </use-case>

     <use-case qid="s011" title="characteristics">
       <query title="all characteristics">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"BBB"
"BBBS"
"something"
"http://something"
"http://something2"
"http://somethingelse"
"Bondpeoplearesoodumb"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb / *
]]></code>
	 </solution>
       </query>
       <query title="all occurrences">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"something"
"http://something"
"http://something2"
"http://somethingelse"
"Bondpeoplearesoodumb"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb / occurrence
]]></code>
	 </solution>
       </query>
       <query title="all homepages">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"http://something2"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb / homepage
]]></code>
	 </solution>
       </query>
       <query title="all comments">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"Bondpeoplearesoodumb"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb / comment
]]></code>
	 </solution>
       </query>
       <query title="untyped name">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"BBB"
"BBBS"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb / name
]]></code>
	 </solution>
       </query>

     </use-case>

     <use-case qid="s0111" title="characteristics atomification">
       <query title="scoped name">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"BBBS"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics name [ . >> scope == sss ] ( . >> atomify  )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics name [ @ sss ] ( . >> atomify )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb / name [ . >> scope == sss ]
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb / name [ @ sss ]
]]></code>
	 </solution>
       </query>
       <query title="characteristics (stringification suppressed), scope filtering">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[4680378be83a353707df9b86e317b868]
[cae2cf3b2444b4066285832c284229f1]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics [@ sss]
]]></code>
	 </solution>
       </query>
       <query title="scope retrieve III">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"BBB"
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
bbb >> characteristics name [ . >> scope == us ] ( . >> atomify )
]]></code>
	 </solution>
       </query>
     </use-case>



<!-- == flowers blossom here ======================================================================================== -->

     <use-case qid="s020" title="basic FLWR">
       <query title="returning simple tuples">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb],2
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
return
   ( bbb, 2 )
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $b in bbb
return
   ( bbb, 2 )
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $b in bbb
return
   ( $b, 2 )
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
for $b in %_ // ccc
return
   ( $b, 2 )
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
for $a in aaa
  for $b in bbb
  return
     ( $b, 2 )
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
for $a in 2
  for $b in bbb
  return
     ( $b, $a )
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
for $b in ccc
   for $a in 2
      for $b in bbb
return
     ( $b, $a )
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
for $b in ccc, $a in 2
    for $b in bbb
return
     ( $b, $a )
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
for $b in bbb, $a in aaa
    for $a in 2
return
     ( $b, $a )
]]></code>
	 </solution>
       </query>
       <query title="returning the map">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[...]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
for $b in %_
return
   ( $b )
]]></code>
	 </solution>
       </query>
     </use-case>

<!-- =============================== WHERE ============================================================ -->

     <use-case qid="s0203" title="WHERE bool">
       <query title="false">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (bbb)
where
   false
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (bbb)
where
    not not false
return
    $a
]]></code>
	 </solution>
       </query>
       <query title="not">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in bbb
where
    not false
return
    $a
]]></code>
	 </solution>
       </query>
       <query title="true">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (bbb)
where
    true
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (bbb)
where
    not not true
return
    $a
]]></code>
	 </solution>
       </query>
       <query title="null">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (ccc)
where
    null
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (ccc)
where
    some $x in null satisfies 1
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (ccc)
where
    some $x in (aaa) satisfies null
return
    $a
]]></code>
	 </solution>
       </query>
       <query title="not null">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[ccc]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (ccc)
where
    not null
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (ccc)
where
    not null | null
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (ccc)
where
    null | not null
return
    $a
]]></code>
	 </solution>
       </query>
       <query title="some satisfies">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    some $b in %_ satisfies true
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    some $_ in %_ satisfies not false
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    some $_ in %_ satisfies $a >> classes == ccc
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    some $_ in $a >> classes thing satisfies true
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    exists $a >> classes *
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    $a >> classes *
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    some $_ in %_ satisfies $a >> classes *
return
    $a
]]></code>
	 </solution>
       </query>
       <query title="exists true">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[...]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_
where
   exists true
return
   $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_
where
   exists false
return
   $a
]]></code>
	 </solution>
       </query>
       <query title="exists false">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_
where
   exists null
return
   $a
]]></code>
	 </solution>
       </query>
       <query title="isa predicated">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    $a >> classes *
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    $a >> classes == ccc
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    $a is-a ccc
return
    $a
]]></code>
	 </solution>
       </query>
       <query title="iko predicated">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (bbb)
where
    $a >> superclasses *
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (bbb)
where
    $a >> superclasses == sss
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (bbb)
where
    $a iko sss
return
    $a
]]></code>
	 </solution>
       </query>
       <query title="nesting">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (bbb)
where
    not (not true)
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (bbb)
where
    $a is-a ccc & (not $a is-a ddd)
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in (bbb)
where
    $a is-a ccc & (not $a is-a ccc | not $a is-a ddd)
return
    $a
]]></code>
	 </solution>
       </query>

       <query title="orand">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[bbb]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    true |  $a is-a ccc & false
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    not false & not $a is-a ddd | false
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    not true & $a is-a ccc | not false
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    true &  $a is-a ccc | false
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    false |  $a is-a ccc | false
return
    $a
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_ // ccc
where
    $a is-a ccc | $a is-a ddd
return
    $a
]]></code>
	 </solution>
       </query>

       <query title="every good">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[...]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_
where
  every $b in %_ // ccc satisfies true
return
   ( $a )
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $a in %_
where
  every $b in %_ // ccc satisfies $b is-a ccc
return
   ( $a )
]]></code>
	 </solution>
       </query>
       <query title="every">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[yyy]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
for $y in %_
where
  every $x in %_ // xxx satisfies 
      $x <- www -> xxx == $y
return
   ( $y )
]]></code>
	 </solution>
       </query>
     </use-case>

     <use-case qid="s0202" title="FLWR IF">
       <query title="if constant">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[aaa]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
return
   if 2 then aaa else bbb
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
return
   if 2 then aaa
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
return
   if () then bbb else aaa
]]></code>
	 </solution>
       </query>
       <query title="if depending">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[aaa]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
return
   if aaa then aaa else bbb
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
return
   if ( bbb >> superclasses  ) then aaa else bbb
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
return
   if vvv then bbb else aaa
]]></code>
	 </solution>
       </query>
       <query title="if nested">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[aaa]
	   </output>
	 </interface>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
return
   if () then
      if ccc then aaa else bbb
   else aaa
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
return
   if 2 then
      if 3 then aaa else bbb
   else ccc
]]></code>
	 </solution>
	 <solution language="tmql" style="flwr" operational="yes">
	 <code><![CDATA[
return
   if ( 2 ) then
      if ( 3 ) then aaa else bbb
   else ccc
]]></code>
	 </solution>
       </query>
     </use-case>

<!-- SELECT -->

     <use-case qid="s030" title="basic SELECT">
       <query title="SELECT results">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
[yyy],42
[zzz],42
[www],42
	   </output>
	 </interface>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
select $a, 42
where
   $a is-a xxx
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
select $a, 42
   where some $b in xxx satisfies $a is-a $b
]]></code>
	 </solution>
       </query>
       <query title="SOME">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[...]
	   </output>
	 </interface>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
select $a
   where some $b in %_ satisfies $a == $b
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
select $a
   where some $b in %_ satisfies $b == $a
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
select $a
   where $a is-a thing 
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
select $a
   where ( some $b in %_ // ccc satisfies true )
         &
         $a is-a thing
]]></code>
	 </solution>
       </query>
       <query title="SOME II">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
	   </output>
	 </interface>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
select $a
   where some $b in %_ satisfies false
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
select $a, $c
   where some $b in %_ satisfies false
         &
         $a is-a ccc
         &
         $c is-a xxx
]]></code>
	 </solution>
       </query>
     </use-case>


<!-- == nested queries ==================================================================================== -->

     <use-case qid="s041" title="nested queries">
       <query title="|| shortcut">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
["nothing"]
["YYY"]
["ZZZ"]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
for $a in %_ // xxx
return
   if $a / name then $a / name else "nothing"
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
for $a in %_ // xxx
return
   $a / name || "nothing"
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
for $a in %_ // xxx
return
   { return $a / name || "nothing" }
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
select $a / name || "nothing"
   where $a is-a xxx
]]></code>
	 </solution>
       </query>

       <query title="nested ++">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
["nothing"]
["nothing"]
["nothing"]
["YYY"]
["ZZZ"]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
for $a in %_ // xxx
return
   { select $a / name }
   ++
   { select "nothing" }
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
for $a in %_ // xxx
return
   { select $a / name }
   ++
   "nothing"
]]></code>
	 </solution>
       </query>

       <query title="outside ++">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
["nothing"]
["YYY"]
["ZZZ"]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
return {
  for $a in %_ // xxx
  return
     { select $a / name }
}
++
{ select "nothing" }
]]></code>
	 </solution>
       </query>

       <query title="outside --">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
["YYY"]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
return {
  for $a in %_ // xxx
  return
     { select $a / name }
}
--
{ select "ZZZ" }
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
return {
  for $a in %_ // xxx
  return
     { select $a / name }
}
--
{ select "ZZZ" }
--
return
  ("ZZZ")
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
return {
  for $a in %_ // xxx
  return
     { select $a / name }
}
--
{ select "ZZZ" }
--
return
  ("AAA")
]]></code>
	 </solution>
       </query>
       <query title="outside --">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
["YYY"]
["ZZZ"]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
return {
  for $a in %_ // xxx
  return
     { select $a / name }
}
--
{ select "AAA" }
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
return {
  for $a in %_ // xxx
  return
     { select $a / name }
}
++
{ select "ZZZ" }
++
{ select "YYY" }
--
{ select "ZZZ" }
--
{ select "YYY" }
]]></code>
	 </solution>
       </query>
<!-- 

TODO: more tests

-->

     </use-case>


<!-- == XML queries ==================================================================================== -->

     <use-case qid="s060" title="static XML">
       <query title="simplistic">
         <interface>
           <input>
             <param name="%_" type="map"    mutable="no"></param>
	   </input>
           <output type="xml"><![CDATA[
   <root><aaa/></root>
]]></output>
	 </interface>
         <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
return
   <root><aaa/></root>
]]></code>
	 </solution>
       </query>
       <query title="nested, blanks">
         <interface>
           <input>
             <param name="%_" type="map"    mutable="no"></param>
	   </input>
           <output type="xml"><![CDATA[
   <root>
	<aaa>something</aaa>
        <bbb>  some
thing   </bbb>
   </root>
]]></output>
	 </interface>
         <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
return
   <root>
	<aaa>something</aaa>
        <bbb>  some
thing   </bbb>
   </root>
]]></code>
	 </solution>
       </query>
       <query title="nested, attributes">
         <interface>
           <input>
             <param name="%_" type="map"    mutable="no"></param>
	   </input>
           <output type="xml"><![CDATA[
   <root>
	<aaa bbb="ccc">something</aaa>
        <bbb xxx="yyy" uuu="vvv">  some
thing   </bbb>
   </root>
]]></output>
	 </interface>
         <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
return
   <root>
	<aaa bbb="ccc">something</aaa>
        <bbb	xxx="yyy"     
   uuu="vvv">  some
thing   </bbb>
   </root>
]]></code>
	 </solution>
         <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
return
   <root>
	<aaa bbb  = "ccc"    >something</aaa>
        <bbb	xxx
="yyy"     
   uuu=
"vvv"  >  some
thing   </bbb>
   </root   >
]]></code>
	 </solution>
       </query>
       <query title="semi-static">
         <interface>
           <input>
             <param name="%_" type="map"    mutable="no"></param>
	   </input>
           <output type="xml"><![CDATA[
<top>
   <whatever/>

   <whatever/>

   <whatever/>
</top>
]]></output>
	 </interface>
         <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
return
<top>{
   for $a in %_ // xxx
   return
   <whatever/>
}</top>
]]></code>
	 </solution>
         <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
return
<top>{
   for $a in %_ // xxx
   return
   <whatever></whatever>
}</top>
]]></code>
	 </solution>
       </query>

       <query title="dynamic, content-only">
         <interface>
           <input>
             <param name="%_" type="map"    mutable="no"></param>
	   </input>
           <output type="xpath"><![CDATA[
/top/whatever[text() = 'YYY']
/top/whatever[text() = 'ZZZ']
/top/whatever[text() = '']
]]></output>
	 </interface>
         <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
return
<top>{
   for $a in %_ // xxx
   return
   <whatever>{$a / name}</whatever>
}</top>
]]></code>
	 </solution>
       </query>
       <query title="dynamic, content-only">
         <interface>
           <input>
             <param name="%_" type="map"    mutable="no"></param>
	   </input>
           <output type="xpath"><![CDATA[
/top[count(/top/whatever/whatta[text() = 'http://something2 AAA Bondpeoplearesoodumb']) = 3]
]]></output>
	 </interface>
         <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
return
<top>{
   for $a in %_ // xxx
   return
   <whatever>
      <whatta>{ bbb / homepage } AAA { bbb / comment }</whatta>
   </whatever>
}</top>
]]></code>
	 </solution>
       </query>
       <query title="dynamic, content-only">
         <interface>
           <input>
             <param name="%_" type="map"    mutable="no"></param>
	   </input>
           <output type="xpath"><![CDATA[
/element/yyy[text() = "aaa"]
/element/yyy[text() = "bbb"]
/element/yyy[text() = "ccc"]
/element/yyy[text() = "aaa"]/following::yyy[text() = "ccc"]
/element/yyy[text() = "aaa"]/following::yyy[text() = "bbb"]
]]></output>
	 </interface>
         <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
return
<element>{
     for $a in ("aaa") ++ ("bbb") ++ ("ccc") return
        <yyy>{$a}</yyy>
}</element>
]]></code>
	 </solution>
       </query>
       <query title="dynamic, attribute values variable">
         <interface>
           <input>
             <param name="%_" type="map"    mutable="no"></param>
	   </input>
           <output type="xpath"><![CDATA[
/element/yyy[@xxx = "aaa"]
/element/yyy[@xxx = "bbb"]
/element/yyy[@xxx = "ccc"]
/element/yyy[@zzz = "uuuaaavvvaaa"]
/element/yyy[@zzz = "uuubbbvvvbbb"]
/element/yyy[@zzz = "uuucccvvvccc"]
]]></output>
	 </interface>
         <solution language="tmql" style="flwr" operational="yes">
	   <code><![CDATA[
return
<element>{
     for $a in ("aaa") ++ ("bbb") ++ ("ccc") return
        <yyy xxx="{$a}" zzz="uuu{$a}vvv{$a}">something</yyy>
}</element>
]]></code>
	 </solution>
       </query>
     </use-case>









<!-- development horizon here -->




     <use-case qid="*****s040" title="prefixes-n-identifiers">
       <query title="identifiers and indication">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"Rumsti"
	   </output>
	 </interface>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
return (http://rumsti.org/ramsti / name)
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
return ( ~ http://rumsti.org/remsti / name)
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
for $b in http://rumsti.org/ramsti
return ($b / name)
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
for $b in =http://rumsti.org/ramsti
return ($b / name)
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
for $b in ~http://rumsti.org/remsti
return ($b / name)
]]></code>
	 </solution>
       </query>
       <query title="prefixing">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"Rumsti"
	   </output>
	 </interface>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
using rumsti import http://rumsti.org/

return ( rumsti:ramsti / name)
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
using rumsti import http://rumsti.org/

return ( ~ rumsti:remsti / name)
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
using rumsti import http://ramsti.org/
using rumsti import http://rumsti.org/
using romsti import http://ramsti.org/

return ( ~ rumsti:remsti / name)
]]></code>
	 </solution>
       </query>
       <query title="nested prefixing">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="set">
"Rumsti"
	   </output>
	 </interface>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
using rumsti import http://xxx.org/
using ramsti import http://ramsti.org/
return 
      {
         using rumsti import http://rumsti.org/
         return ( rumsti:ramsti / name)
        }
]]></code>
	 </solution>
	 <solution language="tmql" style="select" operational="yes">
	   <code><![CDATA[
using rumsti import http://rumsti.org/
return 
      {
         using ramsti import http://ramsti.org/
         return ( rumsti:ramsti / name)
        }
]]></code>
	 </solution>
       </query>
<!-- TODO: predefined prefixes tmql, xsd, op, .... -->
     </use-case>

     <use-case qid="******s041" title="inlined ontology">
       <query title="using AsTMa=">
         <interface>
           <input>
             <param name="%_" type="map"    mutable="no"></param>
           </input>
           <output type="set">
http://adhoc.org/remsti,42
           </output>
         </interface>
         <solution language="tmql" style="select" operational="tyes">
           <code><![CDATA[
using adhoc import http://adhoc.org/ {

   remsti

}
(http://adhoc.org/) (remsti)
]]></code>
	 </solution>
       </query>
     </use-case>





<!-- rubicon 

	 <solution language="tmql" style="pe" operational="y****************es">
	   <code><![CDATA[
( 1, ( (0, 1) * (1, 2) ) ( $1 ), 3 )
]]></code>
	 </solution>


for %_ in http://adhoc.org/ //*
return (remsti, 42)

%_ // xxx


   remsti (xxx) = http://rumsti.org/ramsti
   bn: Remsti


-->


     <use-case qid="*******s0052" title="loop counter">
<!-- problem: where does $# refer to? -->
       <query title="loop counter">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
[0]
[1]
[2]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="yes">
	   <code><![CDATA[
%_ [ * xxx ] ( $# )
]]></code>
	 </solution>
       </query>
       <axiom language="tmql" operational="y********************es">
	 <code><![CDATA[
%_ ( $# )  === %_ ( $# ) ( $# )
]]></code>
       </axiom>
     </use-case>




     <use-case qid="s002" title="integer operation">
       <query title="integer constant">
	 <interface>
           <output type="list">
[42]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
( 42 + 0)
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
( 42 - 21 + 21)
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
( 80 div 4 + 22 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
( 42 * 2 - 42 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
42
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
42 [0]
]]></code>
	 </solution>
       </query>
       <query title="integer comparison">
	 <interface>
           <output type="list">
[1]
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="TODO">
           <code><![CDATA[
( 42 == 42 )
]]></code>
	 </solution>
	 <solution language="tmql" style="pe" operational="TODO">
           <code><![CDATA[
( 0 + 42 == 43 - 1 )
]]></code>
	 </solution>
       </query>

       <query title="multivalue">
	 <interface>
	   <input>
	     <param name="%_" type="map"    mutable="no"></param>
	   </input>
	   <output type="list">
1,2,3
	   </output>
	 </interface>
	 <solution language="tmql" style="pe" operational="TODO">
	   <code><![CDATA[
( 2-1, 1*2, 6 div 3+1 )
]]></code>
	 </solution>
       </query>
     </use-case>





<!-- TODO: empty result 

TODO: test that ALL outgoing roles are returned 
-->




<!-- maybe -->

     <query qid="t07" title="bbb and then projection (slice)">
       <description>
	 bbb and then projection (slice)
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[bbb]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ //* [ @_[0] = bbb ] < @_[0], @_[0] > ! < @_[0] >
]]></code>
       </solution>
     </query>
     <query qid="t08" title="bbb and then projection (slice..)">
       <description>
	 bbb and then projection (slice..)
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[bbb], [bbb]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ //* [ @_[0] = bbb ] < @_[0], @_[0] > ! < @_[0], @_[0] >
]]></code>
       </solution>
     </query>
     <query qid="t09" title="bbb and then projection (slice....)">
       <description>
	 bbb and then projection (slice....)
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[bbb], [bbb]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ //* [ @_[0] = bbb ] < @_[0], @_[0] > ! < @_[0..1] >
]]></code>
       </solution>
     </query>
     <query qid="t10" title="???bbb and then projection (slice....)">
       <description>
???	 bbb and then projection (slice....)
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[...]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ //* [ . = . ]
]]></code>
       </solution>
     </query>
     <query qid="t11" title="???bbb and then projection (slice....)">
       <description>
???	 bbb and then projection (slice....)
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[bbb], [bbb]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ //* [ . = bbb ] < ., . > [ @_[0] = @_[1] ]
]]></code>
       </solution>
     </query>
     <query qid="t12" title="???bbb and then projection (slice....)">
       <description>
???	 bbb and then projection (slice....)
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[bbb]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ //* [ * ccc ]
]]></code>
       </solution>
     </query>
     <query qid="t13" title="all ccc's">
       <description>
	 Retrieve all instances of ccc.
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[bbb]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ // ccc
]]></code>
       </solution>
     </query>
     <query qid="t14" title="all ccc's">
       <description>
???	 Retrieve all instances of ccc.
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[ccc]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ // ccc -> (instance) / (class)
]]></code>
       </solution>
     </query>
     <query qid="t15" title="all ccc's">
       <description>
???	 Retrieve all instances of ccc.
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[ccc]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ // ccc -> instance / class
]]></code>
       </solution>
     </query>
     <query qid="t16" title="all ccc's">
       <description>
???	 Retrieve all instances of ccc.
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[090d83e2edff90ffacde41bc17f0b664]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ < . -> instance >
]]></code>
<!-- %_ // ccc < . -> instance  > -->
       </solution>
     </query>
     <query qid="t17" title="all ccc's">
       <description>
???	 Retrieve all instances of ccc.
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[bbb], [090d83e2edff90ffacde41bc17f0b664]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ // ccc < ., ( . -> instance ) > !
]]></code>
       </solution>
     </query>
     <query qid="t18" title="all ccc's">
       <description>
???	 Retrieve all instances of ccc.
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
[bbb], [090d83e2edff90ffacde41bc17f0b664]
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="noyes">
	 <code><![CDATA[
%_ // ccc < . -> instance  > !
]]></code>
       </solution>
     </query>
     <query qid="t18" title="serializer">
       <description>
serializer
       </description>
       <interface>
	 <input>
	   <param name="%_" type="map"    mutable="no"></param>
	 </input>
         <output type="list">
"bbb"
	 </output>
       </interface>
       <solution language="tmql" style="pe" operational="xxyes">
	 <code><![CDATA[
%_ // ccc #bn `
]]></code>
       </solution>
     </query>

   </database>

</use-cases>

<!--
%_ // bbb < . , . -> instance / class >
 
%_ // * < . , . -> instance / class >

-->

<!--

FOR $a := %_
WHERE
  EXISTS %_ // aaa
return
   ( $a` )

(%_  )   [  (  ($0  ,%_  )   [  ($1  classes)  =  (aaa  )  ]  )  = ... ]   ($0  )

=============================|_____________________________| uses only single variable $1 => can be folded into tuple before

(%_ )    [  (  ($0,   (%_) [ ($0  classes)  =  (aaa  )  ]   )  )  = .... ] ($0)

===== unwrapping =====================

(%_ )    [  (  
               ($0,   (%_) [ ($0  classes)  =  (aaa  )  ]   )
                                                               )  = .... ] ($0)

becomes

(%_ )    [  ($0,   (%_) [ ($0  classes)  =  (aaa  )  ]   )  = .... ] ($0)

===================|_________________________________| does not depend on any $0, $1 => unshift

( (%_) [ ($0  classes)  =  (aaa  )  ],  (%_ ) ) [ ($1, $0) = .... ] ($1)

================================================|_________________| useless: a tuple with only $1 with the same arity (or less) => remove

( (%_) [ ($0  classes)  =  (aaa  )  ],  (%_ ) ) ($1)

================================================|___| projection depending on not used

if (%_) [ ($0  classes)  =  (aaa  )  ]
then 
   (%_)
else
   null



_____________________________________________________________________________________________________
_____________________________________________________________________________________________________

without opt

(  (%_  )  )   [  (  ($0  )  ,  (  ($0  )  ,%_  )   [  ($1  classes)  =  (aaa  )  ]  )   [  (1  )  =  (1  )  ]  = undef ]   (  ($0  )  )

with opt

   (%_  )      [  ($0  ,  (  ($0  )  ,%_  )   [  ($1  classes)  =  (aaa  )  ]  )   [  (1  )  =  (1  )  ]  = undef ]   ($0  )




(  (%_  )  )   [  (  ($0  )  ,  (  ($0  )  ,%_  )   [  ($1  classes)  =  (aaa  )  ]  )   [  (1  )  =  (1  )  ]  = undef ]   (  ($0  )  )

==== unwrapping

(%_)           [  ( $0 , 
                           ( $0, %_ ) [ ($1  classes)  =  (aaa  )  ]
                                                                       )     [ 1 = 1 ]         = undef ]
                                                                                                          ($0)

==== remove trivial predicates

(%_)           [  ( $0 , 
                           ( $0, %_ ) [ ($1  classes)  =  (aaa  )  ]
                                                                       )    =    undef ]
                                                                                                          ($0)

===========================|_______________________________________|  pred chain not referring to $0 -> remove 

(%_)           [  ( $0 ,
                           (%_) [ ($0 classes) = (aaa) ]
                                                                       )    =    undef ]
                                                                                                          ($0)

===========================|___________________________| pe not depending on outer $0 -> unshift

( (%_) [ ($0 classes) = (aaa) ], %_ )
               [  ( $0 , $1 )  =   undef ]
                                            ($1)

===============|_________________________| trivially true when incoming has two columns => remove

( (%_) [ ($0 classes) = (aaa) ], %_ ) ($1)
-->
<!--
FOR $a := %_
WHERE
  SOME $b := %_ SATISFY TRUE
return
   ( $a` )
 (  (%_  )  )   [  (%_  )  = undef ]   (  ($0  )  ) 

== unwrap

   (%_)        [ (%_) ... ] ($0)


-->
<!--
FOR $a := %_
WHERE
  EXISTS %_ // ccc
return
   ( $a` )
            (%_)   [  
                      ($0 , 
                            ($0, %_)  [  ($1  classes)  =  (ccc ) ]
                                                                    )   [  1  = 1 ]

                      = 
                      undef
                     ]
                       ($0)
========================================================== remove [ 1 = 1 ]
            (%_)   [  
                      ($0 , 
                            ($0, %_)  [  ($1  classes)  =  (ccc ) ]
                                                                    )

                      = 
                      undef
                     ]
                       ($0)

========================================================== remove $0 as nothing depends on it (von innen, nach aussen)
            (%_)   [  
                      ($0 , 
                            (%_)  [  ($0  classes)  =  (ccc ) ]
                                                                    )

                      = 
                      undef
                     ]
                       ($0)

==========================  |_________________________________| predicate does not depend on loop context => unshift
unshift $a => (%_)  [  ($0  classes)  =  (ccc ) ]

            (%_)   [  
                      ($0 , 
                            $a
                                 )
                 
                                      ]
                                       ($0)
gives

     ( (%_)  [  ($0  classes)  =  (ccc ) ] , %_) [ 
                                                  ($1 , 
                                                        $0 )          
                                                             ]
                                                               ($1)
=================================================|___________|  trivially true, so omit

     ( (%_)  [  ($0  classes)  =  (ccc ) ] , %_) ($1)

-->
<!--

FOR $a := %_
WHERE
   %_ // ccc
return
   ($a)

== TMQL semantics ================================================================

FOR $a := %_
WHERE
   EXISTS %_ // ccc
return
   ($a)

== TMQL semantics ================================================================

FOR $a := %_
WHERE
   SOME $_ := %_ // ccc SATISFY TRUE
return
   ($a)

== formal semantics ==============================================================

(%_) [ ($0, %_) [ ($1 class) = (ccc) ] [ (1) = (1) ] ] ($0)

== predicate semantics ===========================================================

(%_) [ ( | (%_ class) === (ccc) |, $0, %_) ($1, $2) [ (1) = (1) ] ] ($0)

== predicate semantics ===========================================================

(%_) [ ( | (1) === (1) |, | (%_ class) === (ccc) |, $0, %_) ($2, $3) ] ($0)

== predicate semantics (outer) ===================================================

(%_) ( | ( | (1) === (1) |, | (%_ class) === (ccc) |, $0, %_) ($2, $3) | , $0 ) ($1)

== projection including guards ===================================================

(%_) ( | ( | (1) === (1) |, | (%_ class) === (ccc) |, $0, %_) |, $0 ) ($1)

== preevaluating (1) === (1) has no variables ====================================

(%_) ( | ( | 1 |, | (%_ class) === (ccc) |, $0, %_) |, $0 ) ($1)

== | ( .... %_ ....) | remove ====================================================

(%_) ( | ( | 1 || (%_ class) === (ccc) |, $0) |, $0 ) ($1)

== | ( .... $i ...) | remove if $i is provided ===================================

(%_) ( | ( | 1 |, | (%_ class) === (ccc) |) |, $0 ) ($1)

== | ( .... | x | ... ) |  remove inner || =======================================

(%_) ( | ( 1, (%_ class) === (ccc) ) |, $0 ) ($1)

== | ( ... constant ....) | remove ===============================================

(%_) ( | ( (%_ class) === (ccc) ) |, $0 ) ($1)

== unwrap ========================================================================

(%_) ( | (%_ class) === (ccc) |, $0 ) ($1)

== global guard converted into if ================================================

if | (%_ class) === (ccc) |
   then %_
   else null

_____________________________________________________________________________________________________________
_____________________________________________________________________________________________________________


FOR $b := %_ // ccc
return
    ($b)

== TMQL semantics =============================

(%_) [ ($0 class) = (ccc) ] ($0)

== predicate semantics ========================

(%_) ( | ($0 class) === (ccc) |, $0 ) ($1)

== class <> instance equivalence ==============

(%_) ( | ($0) === (ccc instance) | , $0) ($1)

== $0 is a single-value => drop || ============

(%_) (  ($0 === (ccc instance) , $0) ($1)

== constant selection from %_:    (%_) ($0 === c, $0)   =    (c)($0, $0)

(ccc instance) ($0, $0) ($1)

== single-value projection folding: ===========  ($n, $m) ($0)    =    ($n)

(ccc instances) ($0)

== full projection (same arity): =======     (p0, p1, ..., pn) ($0, $2, $1, ...) = (p0, p2, p1, ...)

(ccc instances)


_____________________________________________________________________________________________________________
_____________________________________________________________________________________________________________

FOR $b := %_
WHERE
    $b is-a ccc
return
    ($b)

== formal semantics

FOR $b := %_
WHERE
    EXISTS $b is-a ccc
return
    ($b)

== formal semantics

FOR $b := %_
WHERE
    SOME $_ := %_ SATISFY $b is-a ccc
return
    ($b)

== formal semantics

(%_) [ ($0, %_) [ ($0 class) = (ccc) ] ] ($0)

== expanding predicate

(%_) [ ($0, %_) ($0 class)    === ($0, %_) (ccc) ] ($0)

== projection

(%_) [ ($0 class) === (ccc) ] ($0)

== macro instances 2

(ccc instances) ($0)

== projection

(ccc instances)

_____________________________________________________________________________________________________________
_____________________________________________________________________________________________________________

SELECT $b
WHERE
   $b instances

== formal semantics

SELECT $b
WHERE
   EXISTS $b instances

== formal semantics

SELECT $b
WHERE
   SOME $_ := %_ SATISFY ($b instances)

== formal semantics

(%_) [ ($0, %_) [ ($0 instances) ] ] ($0)

== expanding predicate (singular)

(%_) [ ( | ($0 instances) |, $0, %_) ($1, $2) ] ($0)

== discard $i variable in last projection inside [] ===

(%_) [ ( | ($0 instances) |, $0, %_) ($1) ] ($0)

== discard $i variable in last projection inside [] ===

(%_) [ ( | ($0 instances) |, $0, %_) () ] ($0)

== discard last empty projection

(%_) [ ( | ($0 instances) |, $0, %_) ] ($0)

== discard $i variable in last projection inside [] ==

(%_) [ ( | ($0 instances) |, %_) ] ($0)

== discard %_ in last projection inside [] ==

(%_) [ (| ($0 instances) |) ] ($0)

== discard trivial $0..$n projection if previous tuple has n-arity

(%_) [ (| ($0 instances) |) ]

________________________________________________________________________________________________
________________________________________________________________________________________________

FOR $a := %_ // ccc
WHERE
   NOT $a is-a bbb
return
   ($a)

== TMQL trafo ===========================

FOR $a := %_ // ccc
WHERE
   EXISTS NOT $a is-a bbb
return
   ($a)

== TMQL trafo ===========================

FOR $a := %_ // ccc
WHERE
   SOME $_ := %_ SATISFY NOT $a is-a bbb
return
   ($a)

== TMQL semantics ======================

(%_) [ ($0 class) = (ccc) ]                 [ ($0, %_) [ ($0 class) /=  (bbb) ] ] ($0)

== negative predicate into complements =======================================================

(%_) [ ($0 class) = (ccc) ]                 [ ($0, %_)   ( ($0) - ($0) [ ($0 class) ==  (bbb) ] ) ] ($0)

== predicate semantics =================================================^^^^^^^^^^^^^^^^^^^^^^^^^^^^===========

(%_) [ ($0 class) = (ccc) ]                 [ ($0, %_)   ( ($0) - ( | ($0 class) ==  (bbb) |, $0 ) ($1) ) ] ($0)

== predicate semantics (pos, outer) =============

(%_) ( | ($0 class) = (ccc) |, $0) ($1)     [ ($0, %_)   ( ($0) - ( | ($0 class) ==  (bbb) |, $0 ) ($1) ) ]  ($0)

== predicate semantics (pos, outer) =============

(%_) ( | ($0 class) = (ccc) |, $0) ($1)     ( | ($0, %_)   ( ($0) - ( | ($0 class) ==  (bbb) |, $0 ) ($1) ) |, $0 ) ($1)  ($0)

== class -> instance ===================================================^^^^^^^^^^^^^^^^^^^^==========

(%_) ( | ($0 class) = (ccc) |, $0) ($1)     ( | ($0, %_)   ( ($0) - ( | ($0) ==  (bbb instance) |, $0 ) ($1) ) |, $0 ) ($1)  ($0)

== class -> instance ==^^^^============================================================================

(%_) ( | ($0) = (ccc instance) |, $0) ($1)  ( | ($0, %_)   ( ($0) - ( | ($0) ==  (bbb instance) |, $0 ) ($1) ) |, $0 ) ($1)  ($0)

== singular values => drop || ==========================================================================

(%_) ( | ($0) = (ccc instance) |, $0) ($1)  ( | ($0, %_)   ( ($0) - ( ($0) ==  (bbb instance) , $0 ) ($1) ) |, $0 ) ($1)  ($0)

== singular values => drop || ==========================================================================

(%_) ( ($0) = (ccc instance), $0) ($1)      ( | ($0, %_)   ( ($0) - ( ($0) ==  (bbb instance) , $0 ) ($1) ) |, $0 ) ($1)  ($0)

==  ( ($0) == p, $0) = (p, p) ==================================================================

(%_) ( ($0) = (ccc instance), ($0) = (ccc instance)) ($1)    ( | ($0, %_)   ( ($0) - ( ($0) ==  (bbb instance) , $0 ) ($1) ) |, $0 )  ($1) ($0)

==  trivial projection: (p, p) ($0) = (p)

(%_) (($0) = (ccc instance))                                 ( | ($0, %_)   ( ($0) - ( ($0) ==  (bbb instance) , $0 ) ($1) ) |, $0 )  ($1) ($0)

==  (%_) ( ($0) == p)     =  (%_) (p) =====================================================================

(%_) ((ccc instance))                                        ( | ($0, %_)   ( ($0) - ( ($0) ==  (bbb instance) , $0 ) ($1) ) |, $0 )  ($1) ($0)

== unwrap

(%_) (ccc instance)                                          ( | ($0, %_)   ( ($0) - ( ($0) ==  (bbb instance) , $0 ) ($1) ) |, $0 )  ($1) ($0)

== projection distributes over - (%_ is firm) ==============================================================

(%_) (ccc instance)                                          ( | ($0) - ( ($0) ==  (bbb instance) , $0 ) ($1) |, $0 ) ($1) ($0)

==  ( ($0) == p, $0) = (p, p) ==================================================================

(%_) (ccc instance)                                          ( | ($0) - ( ($0) ==  (bbb instance) , ($0) ==  (bbb instance) ) ($1) |, $0 ) ($1) ($0)

==  trivial projection: (p, p) ($0) = (p) =======================================================

(%_) (ccc instance)                                          ( | ($0) - ( ($0) ==  (bbb instance) ) |, $0 ) ($1) ($0)

== unwrap =======================================================================================

(%_) (ccc instance)                                          ( | ($0) - ( ($0) ==  (bbb instance) ) |, $0 ) ($1) ($0)

== distribute - over tuple

(%_) (ccc instance)                                        (  ( | ($0) |, $0 )   -    ( | ($0) ==  (bbb instance) |, $0)  ) ($1) ($0)

== singular values => drop || ===================================================================

(%_) (ccc instance)                                        (  ( | ($0) |, $0 )   -    ( ($0) ==  (bbb instance) , $0)  ) ($1) ($0)

== ( ($0) == p, $0) = (p, p) ==================================================================

(%_) (ccc instance)                                        (  ( | ($0) |, $0 )   -    ( ($0) ==  (bbb instance) , ($0) ==  (bbb instance) ) ) ($1) ($0)





== singular values => drop || ==========================================================================

(%_) ( ($0) == (ccc instance), $0) ($1)   ( | ( | ($0 class) /= (bbb) |, $0, %_ ) |, $0) ($1) ($0)

== | ( .... , %_, ....) | remove ==============================================================

(%_) ( ($0) == (ccc instance), $0) ($1)   ( | ( | ($0 class) /= (bbb) |, $0) |, $0) ($1) ($0)

== | ( .... $i ...) remove if provided ========================================================

(%_) ( ($0) == (ccc instance), $0) ($1)   ( | ( | ($0 class) /= (bbb) |) |, $0) ($1) ($0)

== | ( ... | x | ....) remove inner || =========================================================

(%_) ( ($0) == (ccc instance), $0) ($1)   ( | ( ($0) /= (bbb instance) ) |, $0) ($1) ($0)


(%_) ( ccc instance )                      





== (%_) ( ($0) == p, $0)) ($1) = p ===========================================================================



(ccc instance)  - (bbb instance)




== projection =================================================================================^^^

(%_) ( | ($0 class) == (ccc) |, $0) ($1) ( | ( | ($0 class) <==> (bbb) |, $0, %_ ) |, $0) ($1)

== projection (including guards) ==============================================================







-->
<!--
SOME $b := %_ // ccc SATISFY TRUE

                                  (  (%_)   [           ($0)  classes:>:... =  (ccc)  ]  )   [  (1)  =  (1)  ] 

(  (%_)  )   [  (  ($0)  ,  (  ($0)  ,%_)   [  (  ($0)  ,$1)  classes:>:... =  (ccc)  ]  )   [  (1)  =  (1)  ]  = undef ]   (  ($0)  )

   (%_)      [  (  $0  ,       ( $0 , %_)   [  (  $0  ,  $1)  classes:>:... =  (ccc)  ]  )   [  1  = 1  ]  = undef ]   (  $0  )
-->

